## 与memcached的比较

1、Redis相比memcache有更丰富的数据类型，对每种数据类型都有独有的操作方法

2、redis 单线程模型 memcache多线程

3、redis支持持久化

4、redis原生支持分布式

5、**内存管理机制不同**，当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘

memcache劣势：memcache也可以提供存储json格式的字符串实现丰富的数据类型1、memcache server网卡io成为瓶颈 2、client需要提供解码功能

redis丰富的数据类型不是最重要的  重要的是对每种数据类型都有独有的操作方法









# string



正反向索引

get key -2 -1



setnx  



object：key对应的value的编码类型

type：key对应的value所属分组的类型



redis是二进制安全的



msetnx是原子操作  同时成功 同时失败



## 字符串



## 数值



incr

抢购、秒杀、点赞、评论数等场景下  规避并发场景下对数据库的事务操作 完全由redis内存操作代替 





## bitmap位图



setbit

bitcount

bitpos

Bitop



## 位图应用

1、有用户系统 统计用户一定时间范围内登录天数 时间窗口随机

setbit 用户名 一年第几天 登录状态

setbit zwj 2 1

bitcount 用户名 开始天数 结束天数 





2、活跃用户统计  1号-3号 连续登录用户数量  要求去重



setbit 日期 用户id 1

setbit 20210301 201 1

setbit 20210302 202 1



setop or destkey  20210301 20210302  

两个key做或运算 

bitcount destkey 0 -1 统计去重后的活跃用户数







# 底层数据结构

## Sds 简单动态字符串

c语言的字符串类型是字符数组



sds{

int  len; //buf数组已使用字节的数量

int free;//buf数组未使用字节的数量

char buf[];//保存字符串

}



1、sds获取字符串长度为O(1)  c字符串获取字符串长度为O(n)

2、二进制安全 不仅能保存文本 也能保存二进制数据

3、sds不会造成缓冲区溢出  c字符串可能会

由len属性决定是否结束

c语言字符串由'\0'决定





# rdb

管道：

1、衔接 前一个命令的输出作为后一个命令的输入

2、管道会触发创建子进程



linux中 父子进程是数据隔离的
Export的环境变量  父子进程之间的数据修改也算隔离的



fork + copy on write（保持时点性）









## 数据类型







## 数据结构

- 简单动态字符串

```java
struct sdshdr {
    // 记录buf数组中已使用字节的数量，即SDS所保存字符串的长度
    unsigned int len;
    // 记录buf数据中未使用的字节数量
    unsigned int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```



- 跳跃表

有序集合（Sorted Set）

1. **多层**的结构组成，每层是一个**有序的链表**
2. 最底层（level 1）的链表包含所有的元素
3. 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)
4. 跳跃表是一种随机化的数据结构(通过抛硬币来决定层数)



- 压缩列表







## redis高性能

- redis基于纯内存操作，内存读写速度快
- redis单线程，减少线程上下文切换和避免使用锁（保证原子性）
- redis io对路复用模型
- redis自定义数据结构（简单动态字符串、跳跃表）
- 自定义通信协议，编解码简单





## redis持久化

### aof

过程

- 命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；
- 文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；
- 文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。

缓存区的文件同步策略：

​	always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回

​	no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒

​	everysec（推荐）：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次

优点：

1、AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。适合做**热备**

 2、AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。

 3、AOF日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删除紧急恢复，



**AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!**

### rdb（内存快照）

触发方式：

手动触发

​	save（废弃）：save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求)

​	bgsave：bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求

自动触发

​	save m n：指定当m秒内发生n次变化时，会触发bgsave。

优点：

1、RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做**冷备**。
2、RDB对redis对外提供读写服务的时候，影响非常小，因为redis  主进程只需要fork一个子进程出来，让子进程对磁盘io来进行rdb持久化
3、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

缺点：

1、如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，例如1:00进行的快照，在1:10又要进行快照的时候宕机了，这个时候就会丢失10分钟的数据。
 2、RDB每次fork出子进程来执行RDB快照生成文件时，如果文件特别大，可能会导致客户端提供服务暂停数毫秒或者几秒

## redis键的过期策略

- 惰性过期

- 定期过期

每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

处。

- 定时过期





**Redis中同时使用了惰性过期和定期过期两种过期策略。**

## redis的内存淘汰机制

LRU：最近最少使用

- 新数据直接插入到列表头部
- 缓存数据被命中，将数据移动到列表头部
- 缓存已满的时候，移除列表尾部数据。



**allkeys-lru**：从所有key中使用LRU算法进行淘汰

noeviction（默认）：对于写请求不再提供服务，直接返回错误

volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰

allkeys-random：从所有key中随机淘汰数据

volatile-random：从设置了过期时间的key中随机淘汰

volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰



## LRU算法实现



## 主从复制

1、连接建立

2、数据同步

- 全量同步
- 部分同步

3、命令传播

## sentinel哨兵原理



- 定时任务

1、通过向master发送info命令获取最新的主从结构

2、通过发布订阅功能获取其他哨兵节点的信息

3、通过向其他节点发送ping命令进行心跳检测，判断是否下线

- 主观下线

在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线

- 客观下线（只有master节点才需要进行客观下线）

哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线

- 选举领导者哨兵节点

当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。

监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，**谁先完成客观下线，一般就能成为领导者**。

- 故障转移

1、在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。

2、更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。

3、将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。







## 缓存穿透

查询数据库和redis都不存在的数据，导致一直查询数据库

- 布隆过滤器
- 缓存空值



## 缓存雪崩

redis服务宕机   或 大量的数据在同一个时间点全部过期（热点key同时失效）

- redis高可用
- 过期时间随机
- 熔断限流







## 缓存击穿

一个热点key,在不停的扛着大量的并发，当key在失效的瞬间，持续的大并发就会穿破缓存，直接请求到数据库。对数据库造成瞬间压力过大。

- 热点key永不过期
- 互斥锁









## 一致性hash算法



- hash取余分区

计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。

- 一致性hash分区

一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。

![一致性hash分区](images\一致性hash分区.png)





与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。

一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。

- 带虚拟节点的一致性hash分区

该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。**Redis**集群使用的便是该方案，其中的虚拟节点称为槽（slot）。槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash->实际节点，变成了数据hash->槽->实际节点。

**在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小**



##redis cluster原理



redis6.0支持多线程



![redis6多线程](images\redis6多线程.png)







**主要流程**：

1. 主线程负责接收建立连接请求，获取 `socket` 放入全局等待读处理队列；
2. 主线程通过轮询将可读 `socket` 分配给 IO 线程；
3. 主线程阻塞等待 IO 线程读取 `socket` 完成；
4. 主线程执行 IO 线程读取和解析出来的 Redis 请求命令；
5. 主线程阻塞等待 IO 线程将指令执行结果回写回 `socket`完毕；
6. 主线程清空全局队列，等待客户端后续的请求。



思路：**将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行**



我们所说的redis单线程：**Redis 在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的「单线程」**







## 数据库与redis双写一致性



### 第二步操作失败问题

- 先删除缓存，后更新数据库

数据库没有更新成功，那下次读缓存发现不存在，则从数据库中读取，并重建缓存，此时数据库和缓存依旧保持一致



- 先更新数据库，后删除缓存

  删除缓存失败，数据库是最新值，**缓存中是旧值**，发生不一致。所以，这个方案依旧存在问题。





### 读写线程并发问题

- 先删除缓存，后更新数据库



如果有 2 个线程要并发「读写」数据，可能会发生以下场景：

1. 线程 A 要更新 X = 2（原值 X = 1）
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
4. 线程 A 将新值写入数据库（X = 2）
5. 线程 B 将旧值写入缓存（X = 1）

最终 X 的值在**缓存中是 1（旧值）**，在数据库中是 2（新值），发生不一致。

可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。



- 先更新数据库，后删除缓存

依旧是 2 个线程并发「读写」数据：

1. 缓存中 X 不存在（数据库 X = 1）
2. 线程 A 读取数据库，得到旧值（X = 1）
3. 线程 B 更新数据库（X = 2)
4. 线程 B 删除缓存
5. 线程 A 将旧值写入缓存（X = 1）

最终 X 的值在**缓存中是 1（旧值）**，在数据库中是 2（新值），也发生不一致。

这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？

其实概率「很低」，这是因为它必须满足 3 个条件：

1. 缓存刚好已失效
2. 读请求 + 写请求并发
3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）

仔细想一下，条件 3 发生的概率其实是非常低的。

因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。

这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。

所以，我们应该采用这种方案，来操作数据库和缓存。

好，解决了并发问题，我们继续来看前面遗留的，**第二步执行「失败」导致数据不一致的问题**。

### 如何保证两步都执行成功？先修改数据库，后删除缓存

只要第二步发生失败，那么就会导致数据库和缓存不一致。（缓存中是旧值）

**保证第二步成功执行，就是解决问题的关键**。



- mq

<img src="images/redis双写一致性mq方案.jpeg" alt="redis双写一致性mq方案" style="zoom:30%;" />





- 订阅binlog（数据库变更日志）



<img src="images/redis双写一致性mq方案.jpeg" alt="redis双写一致性mq方案" style="zoom:30%;" />











综上，**推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做**。

### 主从库延迟和延迟双删问题

到这里，还有 2 个问题，是我们没有重点分析过的。

**第一个问题**，还记得前面讲到的「先删除缓存，再更新数据库」导致不一致的场景么？

这里我再把例子拿过来让你复习一下：

2 个线程要并发「读写」数据，可能会发生以下场景：

1. 线程 A 要更新 X = 2（原值 X = 1）
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
4. 线程 A 将新值写入数据库（X = 2）
5. 线程 B 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。



**第二个问题**：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。

如果使用「先更新数据库，再删除缓存」方案，其实也发生不一致：

1. 线程 A 更新主库 X = 2（原值 X = 1）
2. 线程 A 删除缓存
3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
4. 从库「同步」完成（主从库 X = 2）
5. 线程 B 将「旧值」写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。

看到了么？这 2 个问题的核心在于：**缓存都被回种了「旧值」**。



怎么解决这类问题呢？

最有效的办法就是，**把缓存删掉**。

但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：**缓存延迟双删策略**。

按照延时双删策略，这 2 个问题的解决方案是这样的：

**解决第一个问题**：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。

**解决第二个问题**：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。

这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。

但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？

- 问题1：延迟时间要大于「主从复制」的延迟时间
- 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间

但是，**这个时间在分布式和高并发场景下，其实是很难评估的。**

很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。



### 结论

1、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」

2、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况

3、采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估

4、采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致

5、采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率










# 一、MySQL事务特性-->ACID



**A：Atomicity原子性**
一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作

**C：Consistency一致性**
一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。在事务开始之前和之后，数据库的完整性约束没有被破坏。

**I：Isolation隔离性**

隔离性要求每个读写事务对其他事务的操作对象能相互分离。

**D：Durability持久性**

持久性指事务一旦提交，其结果就是永久性的。

# 二、数据读取的问题

##（1）脏读

读未提交

##（2）不可重复读

同一个事物，前后多次读取，数据内容不一致（内容被修改或被删除） -> update/delete

##（3）幻读

同一个事物，前后多次读取，数据总量不一样（新增）-> insert 

**幻读在当前读下才会出现，幻读仅指新插入的行**



# 三、事务的实现





# 四、事务的隔离级别

##（1）READ UNCOMMITTED 读未提交

一个事务读取到了另一个事务未提交的数据（脏读）

##（2）READ COMMITTED 读已提交
一个事务能读到另一个已提交事务修改后的数据，但如果其他事务对该数据进进行 修改并提交，该事务还是能读到最新值
解决脏读

##（3）REPEATABLE READ 可重复读（mysql默认隔离级别）

事务能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使后面其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据

mvcc解决了快照读下的幻读问题



解决脏读、不可重复读

（4）SERIALIZABLE

串行化

解决脏读、不可重复读、幻读







版本链

ReadView 



# 五、redo undo binlog

## 1、redo

①作用

**redo log保证事务的持久性**

防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。



**脏页（dirty page）**：当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page脏页。

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求

②内容

**物理格式的日志**，记录的是页的物理修改操作    （内存数据页--->磁盘数据页）

两部分：

**内存中的重做日志缓冲**

**磁盘上的重做日志文件**



③产生时机（redo buffer ---> redo log）

事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，在内存数据页准备修改前将修改信息写入内存中的redo buffer中，然后再对内存数据页中的数据执行修改操作；而且保证在发出事务提交指令时，先向内存中的redo buffer写入日志，写入完成后才执行提交动作；聚集索引、二级索引、undo页面的修改，均需要记录Redo日志

然后会通过以下三种方式将redo buffer刷新到磁盘
1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
2，每个事务提交时会将重做日志buffer刷新到重做日志文件，触发写磁盘过程由参数innodb_flush_log_at_trx_commit控制，表示提交(commit)操作时，处理重做日志的方式。
3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件
由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。

参数 innodb_flush_log_at_trx_commit 有效值有0、1、2（默认1）

- 0表示当提交事务时，并不将事务的重做日志写入磁盘上日志文件，而是等待主线程每秒刷新。Redo buffer —>OS cache ---> flush cache to disk
- 1表示在执行commit时将重做日志缓冲同步写到磁盘，即伴有fsync的调用   Redo Buffer -> OS cache -> flush cache to disk
- 2表示将重做日志异步写到磁盘，即写到文件系统的缓存中。不保证commit时肯定会写入重做日志文件。Redo Buffer ---> OS cache

0，当数据库发生宕机时，部分日志未刷新到磁盘，因此会丢失最后一段时间的事务。

2，当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务。



即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。
这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。

④释放时机

当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。Redo Log 文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写

⑤物理文件

默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&ib_logfile2
　innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。
　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2
关于文件的大小和数量，由以下两个参数配置
　innodb_log_file_size 重做日志文件的大小。
　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1

## 2、undo

①作用

- **undo log保证事务的原子性**，当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
- **undo log 实现MVCC**（Multi-Version Concurrency Control ，多版本并发控制），mvcc通过 undo log 形成一个事务执行过程中的版本链，每一个写操作会产生一个版本，数据库发生读的并发访问时，读操作访问版本链，返回最合适的结果直接返回。从而读写操作之间没有冲突，提高了性能。
- **保证普通select快照读**,**事务未提交之前，undo log保存 了未提交之前版本的数据，undo log中的数据可作为数据旧版本快照供其他并发事务进行快照读**

②内容

undo log 存储的是**逻辑格式**的日志，记录变化的过程，根据每行记录进行记录，保存了事务发生之前的上一个版本的数据，可以用于回滚。当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着 undo 链找到满足其可见性的记录。

- insert undo log
- update undo log

insert undo log是指在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。

而update undo log记录的是对delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。

③产生时机

事务开始之前，将当前事务版本生成 undo log，undo 也会产生 redo 来保证 undo log 的可靠性

④释放时机

当事务提交之后，undo log 并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否有其它事务在使用 undo 段中表的上一个事务之前的版本信息，从而决定是否可以清理 undo log 的日志空间。

⑤物理文件

MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。
MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数
如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。
关于MySQL5.7之后的独立undo 表空间配置参数如下：
　innodb_undo_directory = /data/undospace/ --undo独立表空间的存放目录
　innodb_undo_logs = 128 --回滚段为128KB
　innodb_undo_tablespaces = 4 --指定有4个undo log文件

如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。

## 3、binlog

①作用

　用于主从复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
　用于数据库的基于时间点的还原。

②内容

**逻辑格式**的日志

- statement：基于SQL语句的模式，某些语句中含有一些函数，例如 UUID,NOW 等在复制过程可能导致数据不一致甚至出错。
- row：基于行的模式，记录的是行的变化,很安全。但是 binlog 的磁盘占用会比其他两种模式大很多,在一些大表中清除大量数据时在 binlog 中会生成很多条语句,可能导致从库延迟变大。 
- mixed：混合模式,根据语句来选用是 statement 还是 row 模式。表结构变更使用 statement 模式来记录,如果 SQL 语句是 update 或者 delete 语句,那么使用row模式。

③产生时机

**事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中**。这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。

④释放时机

binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。

⑤物理文件

配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。对于每个binlog日志文件，通过一个统一的index文件来组织。

⑥补充

二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同

## 4、redo和binlog区别

   1，作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。
　2，内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句
　3，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。
　4，恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog

MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。

因为binlog只在提交的时候一次性写入，所以binlog中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。例如事务T1，可能在redo log中记录了 T1-1,T1- 2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果。而且redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中，例如可能redo log的记录方式如下： T1-1,T1-2,T2-1,T2- 2,T2*,T1-3,T1* 。

事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。而binlog记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次。



# 六、锁

##1、共享锁

又称之为 **读锁**，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是自己也不一定能修改（如果针对同一数据有多个事务加了读锁 则各个事务都不能修改这条记录 除非只剩一个事务加了读锁 只有这个事务能修改)；

加锁：select * from user where id = 1 **lock in share mode**;

释放：rollback/commit

##2、排他锁

Insert、uodate、delete默认加排他锁

select * from user where id = 1 for update;

释放：rollback/commit

##3、表锁、行锁（Innodb）

**Innodb存数引擎支持表锁和行锁**

**Myisam仅支持表锁**

**Innodb的行锁是通过给索引上的索引项加锁来实现的。只有通过索引项（包括主键索引）进行数据检索，Innodb才会使用行锁，否则，将使用表锁**

##4、意向共享锁（IS）

表示事务准备给数据行加共享锁，也就是说对一个数据行加共享锁之前必须先获得该表的IS锁

##5、意向排它锁（IX）

表示事务准备给数据行加排它锁，也就是说对一个数据行加排它锁之前必须先获得该表的IX锁

意向锁是Innodb操作数据之前自动加的，无需用户干预。

意向共享锁和意向排它锁的作用在于：**当事务想进行锁表操作时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁（也就是会锁住对于会话），提高了加锁效率。**

6、行锁算法

**mysql加锁规则：**

**1原则一：加锁的基本单位是临键锁(next-key lock) --前开后闭**

**2原则二：查找过程中访问到的对象才会加锁**

**3优化一：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为record lock**

**4优化二：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为gap lock**

**5一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止****





（1）临键锁

当sql执行按照索引进行数据的检索时，查询条件为范围查找（between and < > 等等）并有数据命中，则SQL语句加上的锁为Next-Key locks,锁住索引的记录区间加下一个记录区间，这个区间是左开右闭的

![临键锁](images/临键锁.jpeg)

（2）间隙锁

当sql执行按照索引进行数据的检索时，当记录不存在时，临键锁退化成Gap

在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（左开右开）

![间隙锁](images/间隙锁.jpeg)



**跟间隙锁存在冲突关系的，是’往这个间隙插入一个记录’这个操作，间隙锁之间不存在冲突关系**



（3）记录锁（行锁）

唯一性索引 条件为精准匹配，退化成Record锁

当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这是SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。

![记录锁](images/记录锁.jpeg)





 

读已提交 隔离级别下   查询没有使用到索引 会先锁表  查找的过程中对释放不满足条件的记录的锁



可重复读隔离级别下    查询没有使用到索引 会锁表







七、分布式事务

1、2PC/XA两阶段提交

2、可靠消息最终一致性

3、TCC(Try、Confirm、Cancle)基于业务的一种XA规范的改进解决方案

# 七、sql顺序

##1、sql语句的语法顺序：

(1)SELECT[DISTINCT]

(2)FROM

(3)JOIN

(4)ON

(5)WHERE

(6)GROUP BY

(7)HAVING

(8)UNION

(9)ORDER BY

(10)limit



##2、sql语句的执行顺序：

(1)from 

(3) join 

(2) on 

(4) where 

(5)group by(开始使用select中的别名，后面的语句中都可以使用)

(6) avg,sum.... 

(7)having 

(8) select 

(9) distinct 

(10)union

(11) order by

(12) limit 



# 八、子查询

出现在select语句中的select语句，称为**子查询或内查询。**

外部的select查询语句，称为主查询或外查询

1、子查询分类

按**返回结果集的行列数**不同划分：

标量子查询：结果集只有**一行一列**

列子查询：结果集有只有**一列多行**

行子查询：结果集只有**一行多列**

表子查询：结果集一般为**多行多列**

按**子查询出现在主查询中的不同位置**划分：

select后面：仅支持标量子查询

from后面：支持表子查询

where或having后面：支持标量子查询、列子查询、行子查询

exists后面：支持表子查询；exists子查询，如果exists后的子查询能查出数据，则表示存在；为空则不存在



# 九、索引



innodb和myisam存储引擎索引的数据结构都是B+树

特点：

非叶子节点不存储数据

叶子结点存储数据

叶子结点之间通过指针连接



innodb-聚集索引 

myisam-非聚集索引



innodb引擎主键建议使用int型自增id



如果查询优化器发现通过辅助索引查到的数据量大于全表数据量的80%，查询优化器会进行全表扫描

mysql的utf-8只有0-3个字节 java中的utf-8是0-4个字节 后面ysql提供了utf8mb4（增加了表情） 这个才是我们通常意义上的utf-8



# 十、存储引擎



myisam 





innodb

 



操作系统 一页 4kb 局部性原理

innodb一页 16kb  16384个字节



varchar(20) 20个字符  1个字符所占空间和字符集相关

innodb一行数据最长65535个字节  





B+数：一个节点可以存储多条数据 叶子节点有指针连接 非叶子节点冗余在节点  有序



索引的代价：占用空间；每次更新字段需同时更新索引





**select的列如果不在group by的列当中，并且根据group by 后面的列分组后任意列不能有唯一值，则这些不包含在group by 中的列都应该使用max或者min聚合函数**

**select的列如果不在group by的列当中，并且根据group by 后面的列分组后任意列均有唯一值，则这些不包含在group by 中的列可以不使用max或者min聚合函数**















# 十一、查询优化器

基于成本（IO成本+CPU成本）：

读取页面的成本（从磁盘加载到内存 规定加载每页成本为1.0）+ 检测一行记录是否符合搜索条件(规定每行成本为0.2)

因此 总成本 = 需读取的页面数  * 1.0 + 需检测的总记录数 * 0.2



1、全表扫描成本

估算全表有多少页 + 估算全表有多少行



2、索引扫描

2.1主键索引 

范围区间个数  * 1.0  +  估算各个范围区间有多少行 * 0.2（in()后面的参数（即范围区间）如果小于200，那么会使用比较精确的方式去估算，否则取统计值 即每个参数column对应的行数为 count(column) / distinct(column)）   每隔= 、in、 <、 >都算范围区间（in后面每隔参数算一个范围区间） 

2.2辅助索引 

辅助索引扫描（范围区间个数 * 0.1 +  估算各个范围区间有多少行 * 0.2） + 回表成本

**select** * **from** employees.titles **where** 主键字段 in (主键值1，主键值2，主键值3...)



3、统计数据

3.1异步统计

3.2analyze table





# 十二、Join优化

1、原理

 **Block Nested-loop join** 嵌套循环连接

1. 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的访问形式来执行对驱动表的单表查询。
2. 对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。

2、优化

**内连接优化** ==> 增加join buffer   可以一次性去被驱动表查询更多驱动表中的数据   只有被驱动表的join字段没有建立索引才会使用join buffer    

**外连接优化** ==>   外连接消除 外连接优化成内连接   使得可以利用查询优化器选择小表驱动大表  左连接和右连接中的驱动表是固定的（驱动表不一定是小结果集）  查询优化器不会去进行优化 内连接的驱动表不是固定的 查询优化器可以进行优化(小结果集驱动大结果集)

**小结果集驱动大结果集**

**被驱动表上join字段建立索引**

**On vs where** 

ON 条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从 B 表中检索数据行。如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据,在匹配阶段 WHERE 子句的条件都不会被使用。**仅在匹配阶段完成以后，WHERE 子句条件才会被使用**。**ON将从匹配阶段产生的数据中检索过滤**







mysql不允许先查询一个表 再更新这个表

错误（mysql不支持）：update t1 set  c = 1 where a in (select b from t1)  

正确：update t1 set c = 1 where a in (select d.b from (select b from t1) as d)



派生表优化 









表很大 性能下降？

增删改变慢

少量查询能走索引依然很快

并发查询或没有命中索引很慢









# 十三、explain关键字



mysql explain

![mysql explain](\images\mysql explain.png)

## 1、id

id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。

- id相同时，执行顺序由上至下
- id不同时，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
- id不同又相同，如果id相同，则认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行



## 2、select_type

A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个
B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个
C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union
D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select



## 3、table

显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived N>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union M,N>，与<derived N>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。

## 4、type

依次从好到差：null、system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引



- `NULL` MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引

- `system`：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index

- `const`：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const

- `eq_ref`：联表查询的情况，按联表的主键或唯一键联合查询。多表`join`时，对于来自前面表的每一行，在**当前表中只能找到一行**。这可能是除了`system`和`const`之外最好的类型。当主键或唯一非`NULL`索引的所有字段都被用作`join`联接时会使用此类型

- **ref**：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行

- `fulltext`：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引

- `ref_or_null`：与ref方法类似，只是增加了null值的比较。实际用的不多。

- `unique_subquery`：用于where中的in形式子查询，子查询返回不重复值唯一值

- `index_subquery`：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。

- **range**：索引范围扫描，只检索给定范围的行，常见于使用>,<,is null,between ,in ,like等运算符的查询中，这种范围扫描索引比索引权标扫描（index）要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引

- `index_merge`：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range

- **index**：**索引全表扫描**，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。

- **all**：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。



## 5、possible_keys字段

这个表里面存在且可能会被使用的索引，可能会在这个字段下面出现，但是一般都以`key`为准。

## 6、key字段



**key列显示MySQL实际决定使用的键（索引）**

如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

## 7、key_len

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）

不损失精确性的情况下，长度越短越好 

key_len大小的计算规则:
a、一般地，key_len 等于索引列类型字节长度，例如int类型为4-bytes，bigint为8-bytes；
b、如果是字符串类型，还需要同时考虑字符集因素，例如：CHAR(30) UTF8则key_len至少是90-bytes；
c、若该列类型定义时允许NULL，其key_len还需要再加 1-bytes；
d、若该列类型为变长类型，例如 VARCHAR（TEXT\BLOB不允许整列创建索引，如果创建部分索引，也被视为动态列类型），其key_len还需要再加 2-bytes;



## 8、ref字段

**表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值**



##  9、rows

 **表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数**



## 10、extra

**该列包含MySQL解决查询的详细信息,有以下几种情况：**

Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤

**Using index** :覆盖索引

**Using temporary**：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询

**Using filesort**：MySQL中无法利用索引完成的排序操作称为“文件排序”

**Using join buffer**：强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。

Impossible where：这个值强调了where语句会导致没有符合条件的行。

Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行

Using index for group-by :对于group by列或者distinct列，可以利用索引检索出数据，而不需要去表里查数据、分组、排序、去重等等

Select tables optimized away：在没有group by子句时，对于MyISAM的select count(*)操作，或者当对于min(),max()的操作可以利用索引优化，优化器发现只会返回一行。

**总结：**

- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
- EXPLAIN不考虑各种Cache
- EXPLAIN不能显示MySQL在执行查询时所作的优化工作
- 部分统计信息是估算的，并非精确值
- EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。**

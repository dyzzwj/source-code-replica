jvm内存结构分为类加载器子系统、运行时数据区、执行引擎

# 一、类加载器子系统

## 1、类的加载过程

###（1）加载 

将类的class文件读入到内存

①通过一个类的全限定名称来获取定义此类的二进制字节流。

②将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

③在java堆中生成一个代表这个类的**java.lang.Class对象**，作为方法区这些数据的访问入口。

###（2）链接

①验证 检查加载的 class 文件的正确性

文件格式的验证、元数据的验证、字节码验证和符号引用验证

②准备  给类中的静态变量分配内存空间；

为类变量分配内存并设置该类变量的默认初始值，不包含使用final修饰的类变量，因为final在编译的时候就分配了，准备阶段会显式初始化

③解析 虚拟机将常量池中的符号引用替换成直接引用的过程

将常量池中的符号引用转为直接引用的过程

符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，与VM实现的内存布局无关，引用的目标并不一定已经加载到内存中。

直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用于VM实现的内存布局相关，引用的目标必定已经在内存中存在。

###（3）初始化 静态变量和静态代码块执行初始化工作。

**执行类构造器<clinit>()方法的过程（类变量的赋值以及静态代码块）**

1.<clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生；
 2.<clinit>()不需要显式地调用父类构造器，VM保证在调用<clinit>()之前就已经执行完父类的<clinit>()，所以VM中第一个被执行的<clinit>()的类肯定是java.lang.Object；
 3.父类中定义的静态语句优先于子类的变量赋值操作；
 4.<clinit>()对于类或接口并不是必须的，若一个类中没有静态语句块也没有对变量的赋值操作，编译器不会生成<clinit>()方法；
 5.接口中不能使用静态语句块，但仍然有变量初始化赋值操作，所以接口会生成<clinit>()方法，但是，接口的<clinit>()不需要先执行父接口的<clinit>()，且实现类初始化时不会执行接口的<clinit>()方法。
 6.VM会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。



## 2、类加载器分类

###（1）引导类加载器（启动类加载器）

Bootstrap ClassLoader  **c实现**

负责将 `<JAVA_HOME>/lib`路径下的核心类库或`-Xbootclasspath`参数指定的路径下的jar包加载到内存中，如rt.jar、resource.jar

出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

加载扩展类加载器和应用类加载器，并指定为他们的父类加载器

###（2）扩展类加载器

Extension ClassLoader -> sun.misc.Launcher.ExtClassLoader

负责加载`<JAVA_HOME>/lib/ext`目录下或者由系统变量-Djava.ext.dir指定位路径中的类库

###（3）应用类加载器（系统类加载器）

AppClassLoader -> sun.misc.Launcher.AppClassLoader

加载系统类路径`java -classpath`或`-Djava.class.path` 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器

## 3、双亲委派机制

（1）、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行

（2）、如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器

（3）、如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载



在jvm中表示两个class对象是否为同一个类存在两个必要条件：

①类的完整类名必须一致，包括包名

②加载这两个类的ClassLoader实例必须相同



### tomcat打破双亲委派机制



#### 原理

实现ClassLoader接口，重写loadClass方法



#### 为什么要重写

- 对于各个 `webapp`中的 `class`和 `lib`，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。
- 与 `jvm`一样的安全性问题。使用单独的 `classloader`去装载 `tomcat`自身的类库，以免其他恶意或无意的破坏；
- 热加载。相信大家一定为 `tomcat`修改文件不用重启就自动重新装载类库而惊叹吧。

## 4、类的主动使用和被动使用

（1）创建类的实例
（2）访问某个类或接口的静态变量，或者对该静态变量赋值
（3）调用类的静态方法
（4）反射`（如Class.forName(“com.bunny.Test”)）`
（5）初始化一个类的子类
（6）Java虚拟机启动时被标明为启动类的类

# 二、程序计数器(PC Register)



jvm的程序计数器是对物理程序计数器的一种抽象模拟

PC寄存器用来存储指向下一条指令的地址

**线程私有，与线程的生命周期保持一致**

**jvm规范中唯一一个没有规定任何OutOfMemory的区域**

# 三、虚拟机栈



##1、概述

栈是运行时的单位 而堆是存储的单位

**每个线程在创建时都会分配一个虚拟机栈，其内部保存着一个一个的栈帧，每个栈帧都对应着一次方法调用**

**虚拟机栈是线程私有的 ，生命周期和线程一致**

**jvm对栈的操作：进栈（方法调用） 出栈（方法返回） 栈不存在垃圾回收问题**

栈中可能出现的异常：

**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；**

**如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；**

**-Xss：设置线程的最大栈空间（固定大小的虚拟机栈）** 栈的大小决定了函数调用的最大可达深度

**栈不存在GC**

##2、栈的存储结构

先进后出 FILO

每个线程都有自己的栈，栈的存储结构是栈帧

在这个线程上正在执行的每个方法都各自对应一个栈帧

不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧（保证局部变量的线程安全性）

##3、栈帧的内部结构

每个栈帧存储着局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息

###（1）局部变量表（Local Variable）

定义为一个数组，主要用于存储方法参数和定义在方法内部的局部变量，数据类型为8中基本数据类型、对象实例的引用和returnAddress

局部变量表中的数据不存在线程安全问题

局部变量表的大小是在是在编译期确定下来的，保存在方法表的Code属性的max_locals数据项中

局部变量表的数据只在当前方法（栈帧）调用中有效，方法调用结束后，局部变量表随着栈帧的销毁而销毁

局部变量表存放的数据类型包括8种基本数据类型、引用类型、returnAddress类型 

如果是实例方法或构造方法创建的栈帧，该对象this引用将会存放在index为0的slot处，其余参数则按照参数列表的顺序来排列

局部变量表的存储单位是slot（槽）

32位以内的占用一个slot（包括returnAddress），64位的占用两个slot（long和double类型）

局部变量表中的槽位是可以重用的

**局部变量表中的变量是重要的GCRoots，只要被局部变量表中直接引用或间接引用的对象都不会被回收**

###（2）操作数栈（Operation Stack）

**先进后出 LIFO**

在方法执行过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈）

操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间

**每个操作数栈的最大深度在编译期间就确定下来了**

如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中



###（3）动态链接（Dynamic Linking）

**指向运行时常量池的方法引用**

**每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**

**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



静态绑定 -->动态绑定

静态链接-->动态链接

非虚方法-->虚方法



静态方法、私有方法、final方法、实例构造器、父类方法（子类中通过super().调用父类方法）



###（4）方法返回地址（Return Address）

方法正常退出或异常退出的定义

存放调用该方法的pc寄存器的值

# 四、本地方法栈

线程私有 

管理本地方法的调用

mative关键字可以与所有其他的Java关键字使用，abstract除外

# 五、堆

## 1、概述

堆可以处于物理上不连续的空间，但逻辑上它应该被视为连续的

**堆是线程共享的，几乎所有的对象都在堆分配，堆是垃圾回收的主要区域**

**堆的内存划分：**

Jdk7：年轻代 + 老年代 + 永久代

Jdk8：年轻代 + 老年代 + 元空间



## 2、设置堆内存大小

-Xms：堆空间起始大小

-Xmx：堆空间最大大小

通常会将-Xms和-Xmx设置成一样的值，避免频繁的回收和分配堆内存

## 3、年轻代与老年代

**堆区可以划分为年轻代和老年代**

**年轻代可以划分为伊甸园区、幸存者0区、幸存者1区（伊甸园区、from区、to区）**

**年轻代与老年代的比例：**

-XX:NewRatio：默认为2，即年轻代与老年代的比例为1：2

伊甸园区和幸存者0区幸存者1区的比例：

-XX:SurvivorRatio：默认为8，即伊甸园区域幸存者0区、幸存者1区的比例为8：1：1

几乎所有的对象都是在伊甸园区被new出来的

注：幸存者0区和幸存者1区，谁空谁是to

垃圾收集：频繁在年轻代收集，很少在老年代收集，几乎不在永久代（元空间）收集



# 4、Minor GC、Major GC、Full GC

部分收集：不是完整收集整个Java堆（包括方法区）的垃圾收集，其中又分为：

年轻代收集(Minor GC)：只是新生代（伊甸园区、幸存者0、1区）的垃圾回收

老年代收集(Major GC)：只是老年代的垃圾回收

​		目前，只有CMS GC会有单独收集老年代的行为   Major GC执行之前，经常会伴随着至少一次的Minor GC

​		注意，很多时候Major GC和Full GC会混合使用，需要具体分辨是老年代回收还是整堆回收

混合收集：收集整个年轻代以及部分老年代

​		目前，只有G1 GC会有这种行为



整堆收集（Full GC）：收集整个java堆和方法区

Minor GC触发条件：

当年轻代的伊甸园区空间不足时，会触发Minor GC（幸存者0区或幸存者1区满不会触发Minor GC，幸存者0区或幸存者1区属于被动GC，即由伊甸园区空间不足而引发的MinorGC）

Major GC触发条件：老年代空间不足时，会触发Major GC。Major GC执行之前，经常会伴随着至少一次的Minor GC

Full GC触发条件：

①调用System.gc();系统建议执行Full GC，但是不一定会执行

②老年代空间不足

③方法区空间不足

④通过Minor GC后进入老年代的平均大小大于老年代的可用内存

⑤由伊甸园区、from区向to区复制时，转移的对象大小大于to区，则把该对象转移到老年代，此时如果老年代的可用内存小于该对象大小





**java对象创建方式：**

new

Class.newInstance()

Constructor.newInstance()

使用clone();

使用反序列化



对象创建的6步：

1. 判断对象对应的类是否加载、链接、初始化
2. 为对象分配内存，计算占用空间的大小（确定的）
   - 内存规整-指针碰撞（整块空间）
   - 内存不规整-空闲分配列表（碎片化的空间）
3. 处理并发问题
4. 初始化分配到的空间（赋默认初始化值）
5. 设置对象头（所属的类，对象的HashCode，对象的GC信息、锁信息）
6. init方法初始化（属性的显式初始化、代码块初始化、构造器初始化）

​	

对象头：hashcode、对象分代年龄、锁标志位



# 六、方法区

# 1、概述

方法区看作是一块独立于Java堆的内存空间

**线程共享**

方法区溢出会抛出OutOfMemoryError: PermGen space(jdk1.7及以前)或OutOfMemoryError:Meta space(jdk1.8及以后)

jdk7及以前，习惯把方法区称为永久代，jdk8开始，使用元空间取代永久代

**元空间不在虚拟机设置的内存中，而是使用本地内存**

jdk7及以前：-XX:PermSize

​				 -XX:MaxPermSize

jdk8及以后：-XX:MetaspaceSize

​					 -XX:MaxMetaspaceSize



## 2、方法区的内部结构

存储内容：**类型信息、域信息（属性）、方法信息、运行时常量池、静态变量**、JIT代码缓存

## 3、常量池

字面量：数量值、字符串值

符号引用：类引用、字段引用、方法引用

常量池，可以看做是⼀张表，是class字节码文件的一部分，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

运行时常量池是方法区的一部分。jvm为每个已加载的类型都维护一个常量池

## 4、方法区的演进（Hotspo虚拟机）

**Jdk6:有永久代，静态变量和字符串常量池存放在永久代**

**Jdk7:有永久代，静态变量和字符串常量池存放在堆**

**Jdk8:无永久代，类型信息、字段、方法、运行时常量池、JIT代码缓存保存在本地内存的元空间，静态变量和字符串常量池存放在堆**

## 5、垃圾收集

对常量池的回收：只要常量池中的常量没有被任何地方引用，就可以被回收

对类型的回收：

1.Java堆中不存在该类的任何实例对象；

2.加载该类的类加载器已经被回收；

3.该类对应的java.lang.Class对象不在任何地方被引用，且无法在任何地方通过反射访问该类的方法。





# 七、StringTable



##1、概述

String被声明为final类型，不可被继承

String实现了Serializable（表示String可以被序列化）、Comparable（表示String可以比较大小）

jdk8及以前：String内部是用final char value[]存储数据 char 2字节

jdk9及以后：String内部是用final byte value[]存储数据  byte 1字节



StringBuild 线程不安全 效率更高 

StringBuffer线程安全 效率略低



**字符串常量池中不会存储相同内容的字符串**

**直接使用双引号声明的String对象会直接放入字符串常量池** String name = "zwj"

jdk6及以前，字符串常量池存放在永久代

jdk7及以后，字符串常量池存放在堆



##2、字符串拼接操作

**（1）、常量（包括字符串常量和常量引用(final修饰的引用变量)）与常量的拼接结果在常量池，原理是编译期优化**

**（2）、常量池不会存储内容相同的常量**

**（3）、拼接操作中只要有一个是变量（不包括final修饰的变量），结果就在堆中 变量拼接的原理是StringBuilder**

**（4）、如果拼接的结果调用intern()方法，String#intern()方法：从字符串常量池中查询当前字符串是否存在，若存在就返回常量池中字符串常量的地址，若不存在就将当前字符串对象放入常量池中并返回池中字符串常量地址**



##3、String.intern()

jdk1.6中 尝试将这个字符串对象放入字符串常量池（串池）

- 如果串池中有，则并不会放入，返回串池中已有的对象的地址
- 如果串池中没有，**则会把此对象复制一份**，放入串池，并返回串池中对象的地址	

jdk1.7中，尝试将这个字符串对象放入字符串常量池（串池）

- 如果串池中有，则并不会放入，返回串池中已有的对象的地址
- 如果串池中没有，**则会把对象的引用地址复制一份**，放入串池，并返回串池中的引用地址



String s1 = “a”;

String s2 = “b”;

Strinng s3 = s1 + s2;

S1+s2的实现方式：jdk1.5及之后是StringBuilder(线程不安全)，jdk1.5之前是StringBuffer(线程安全)

①StringBuilder sb = new StringBuilder();

②sb.append(“a”);

③sb.append(“b”);

④sb.toString();





new String(“ab”)创建了几个对象？

两个：一个对象是new关键字在堆中创建的，一个对象是字符串常量池中的对象（不存在则创建，存在则复用）



new String(“a”) + new String(“b); 创建了几个对象？

对象一：new StringBuilder()

对象二：new String(“a”)

对象三：字符串常量池中的”a”

对象四：new String(“b);

对象五：字符串常量池中的”b”

继续深入：StringBuilder.toString()

对象六：new String(“ab”);

补充：toString()的调用，没有在字符串常量池中生成”ab”

```java
 				String s = new String("1");
        s.intern();//调用此方法之前，字符串常量池中已经存在了"11"
        String s2 = "1";//s2记录的是常量池中"1"对应的地址
        System.out.println( s == s2);//jdk6:false    jdk7:false


        String s3 = new String("1") + new String("1");//s3记录是堆中的"11"的地址
				//上面代码执行完后，字符串常量池中还没有"11"
        s3.intern();//在字符串常量池中生成"11"   
        String s4 = "11";//s4记录的地址是上一行代码执行时，在常量池中生成的"11"的地址
        System.out.println(s3 == s4);//jdk6:false  jdk7:true
```





# 八、垃圾回收

##1、概述

垃圾：运行程序中没有任何指针指向的对象

堆是垃圾回收的重点，频繁收集年轻代、较少收集老年代、基本不动元空间（永久代）

##2、垃圾回收相关算法

标记阶段

①引用计数算法

对每个对象保存一个整型的引用计数属性，用于记录对象被引用的情况

无法处理循环引用

②可达性分析算法（根搜索算法）

以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达，只有能够被根对象集合直接连接或间接连接的对象才是存活对象

GC Roots:

- **虚拟机栈中引用的对象**

- 本地方法栈内JNI引用的对象

- **方法区中类静态属性引用的对象**

- **所有被同步锁（synchronized）持有的对象**

- java虚拟机内部的引用

- 根据⽤户所选⽤的垃圾收集器以及当 前回收的内存区域不同,还可以有其他对象"临时性"地⼊,共同构成完整GC Roots集合.⽐如:分代收集和局部回收(PartialGC) 

  如果只针对java堆中的某⼀块区域进⾏垃圾回收(⽐如:典型的只针 对新⽣代),必须考虑到内存区域是虚拟机⾃⼰的实现细节,更不是孤 

  ⽴封闭的,这个区域的对象完全有可能被其他区域的对象所引⽤,这时候就需要⼀并将关联的区域对象也加⼊GCRoOTS集合中去考虑, 

  保才证能可达性分析的准确性. 

注：**枚举GC Roots是Stop The World的重要原因**

回收阶段

①标记-清除算法

②复制算法

③标记-整理算法









##3、finalization机制

finalization()允许开发人员提供对象被销毁之前的自定义处理逻辑

垃圾回收器回收此对象之前，总会先调用这个对象的finalize()

永远不要主动调用对象的finalize()方法，应该交给垃圾回收机制调用

**finalize()方法只会被调用一次**，一般用于在对象被回收时进行资源释放



对象状态：

可触及的：从根节点开始，可以到达这个对象

可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活

不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态，不可触及状态的对象不可能被复活，因为finalize()方法只会被调用一次

##4、标记-清除算法

标记：垃圾收集器从引用根节点开始遍历，标记所有被引用的对象，在对象的header记录为可达对象

清除：垃圾回收器对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有被标记为可达对象，则将其回收



缺点：内存碎片化，需要维护一个空闲列表



##5、复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

优点：没有标记和清除过程

​			复制过去以后保证空间的连续性，不会出现碎片化问题

缺点：需要两倍的内存空间

​			系统中的垃圾很多，即需要复制的存活对象（非垃圾）比较少，使用复制算法



##6、标记-压缩算法

标记：垃圾收集器从引用根节点开始遍历，标记所有被引用的对象（非垃圾），一般是在对象头的Header中记录为可达对象

压缩（整理）：将所有存活的对象压缩（移动）到内存的一端，按顺序排放，之后，清理边界外所有的空间



##7、一些算法思想

分代收集算法（思想）：针对年轻代和老年代的特点，具体问题具体分析

增量收集算法：垃圾收集器每次只回收一小片区域的内存空间，紧接着切换到用户线程，依次反复，直到垃圾收集完成

分区算法：将一块大的内存区域分割成多个小区间（region），根据目标停顿时间，每次合理的回收若干个小区间。每个小区间都独立使用，独立回收

增量收集算法和分区算法都是为了控制GC产生的停顿时间，达到低延迟的目标



##8、强软弱虚

强引用（StrongReference：不回收）：如果一个对象具有强引用，无论任何情况下**垃圾回收器**都不会回收它

软引用（SoftReference：内存不足即回收）：如果一个对象只具有**软引用**，则**内存空间充足**时，**垃圾回收器**就**不会**回收它；如果**内存空间不足**了，就会**回收**这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。**应用场景：缓存**

弱引用（WeakReference：发现即回收）：被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收弱引用关联的对象。**应用场景：缓存**

虚引用（PhantomReference：对象回收跟踪）:⼀个对象是否有虚引⽤的存在,完全不会对成生存时间构成影响,也⽆法通过虚引⽤来获得⼀个对象的实例。虚引用**主要用来**跟踪对象**被垃圾回收器**回收**的活动，为⼀个对象设置虚引⽤关联的唯⼀⽬的就是能在这个对象被收集器回收时收到⼀个系统通知



# 九、垃圾回收器

##1、评估GC的性能指标

吞吐量：运行用户代码的时间占总运行时间的比例

暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间

##2、分类

按工作模式分

串行：Serial GC、Serial Old GC

并行：ParNew GC、Parallel New GC、Parallel Old GC     **多个GC线程同时工作**

并发：CMS、G1     **GC线程和工作线程并发执行**



按工作区域分

新生代：Serial GC、ParNew GC、Parallel New GC

老年代：Serial Old GC、Parallel Old GC、CMS

整堆垃圾回收：G1

<img src="images/垃圾回收器组合关系.png" alt="垃圾回收器组合关系" style="zoom:50%;" />

![垃圾回收器组合关系说明](images/垃圾回收器组合关系说明.png)



##3、Serial GC：串行回收

年轻代、复制算法、串行回收、STW

##4、Servial Old GC：串行回收

老年代、标记-压缩算法、串行回收、STW

Serial Old可以作为老年代CMS收集器的后备垃圾收集方案

单核场景下使用：-XX:UseSerialGC

##5、ParNew GC：并行回收

年轻代、复制算法、并行回收、STW

PaeNew + CMS

使用：-XX:UseParNewGC

##6、Parallel GC：吞吐量优先

年轻代、复制算法、并行回收、STW

目标是达到一个可控制的吞吐量，有自适应调节策略

适合在后台运算较多而不需要太多交互的任务（高吞吐量）

使用：-XX:UserParallelGC

##7、Parallel Old GC：吞吐量优先

老年代、标记-压缩、并行回收、STW

使用：-XX:UseParallelOldGC

**jdk8默认垃圾回收器：Parallel GC + Parallel Old GC**

-XX:ParallelGCThreads：设置并行GC的线程数

##8、CMS：低延迟

老年代、标记-清除算法、并发收集、短暂STW

初始标记：标记出GC Roots能直接关联到的对象   **STW**、非常快

并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程 无需STW、耗时较长

重新标记：修正并发标记阶段，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录     **STW**，比初始标记略长

并发清除：清理删除标记阶段判断的已经死亡的对象，释放内存空间 无需STW



由于在垃圾收集阶段用户线程没有中断，所以CMS回收过程中，还应该确保用户线程有足够的内存可用，所以，CMS只能当堆内存达到某一阈值时，便开始运行回收（其他垃圾收集器可以等到老年代几乎被填满时再进行回收）

缺点：内存碎片

对CPU资源敏感

无法处理浮动垃圾



##9、G1：区域化分代式

整堆收集

每次根据允许的收集时间，优先回收价值最大（垃圾最多）的Region

jdk9以后的默认垃圾回收器

特点

并行与并发：

分代收集：将堆空间划分为若干个区域，这些区域包含了逻辑上的年轻代和老年代

空间整合：Region之间是复制算法，整体上可以看成是标记-压缩算法

可预测的停顿时间模型：每次根据允许的收集时间，优先回收价值最大（垃圾最多）的Region，保证G1在有限的时间内可以获取尽可能高的回收效率



使用：-XX:UseG1GC

适用场景：大内存、多处理器



分区：

所有的Region大小相同，且在jvm生命周期内不会被改变

-XX:G1HeapRegionSize









